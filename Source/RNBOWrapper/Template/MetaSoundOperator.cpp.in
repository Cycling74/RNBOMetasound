// based on Copyright Epic Games, Inc. All Rights Reserved.
#define LOCTEXT_NAMESPACE "MetasoundStandardNodes_OPERATOR_NAME_"

namespace _OPERATOR_NAME_
{
	using namespace Metasound;
	using namespace RNBOWrapper;

	namespace 
	{
        const RNBO::Json desc = RNBO::Json::parse(_OPERATOR_DESC_);

        /*
        static const std::vector<FRNBOMetasoundParam>& InputFloatParams() {
            static const std::vector<FRNBOMetasoundParam> Params = FRNBOMetasoundParam::InputFloat(desc);
            return Params;
        }

        static const std::vector<FRNBOMetasoundParam>& InputAudioParams() {
            static const std::vector<FRNBOMetasoundParam> Params = FRNBOMetasoundParam::InputAudio(desc);
            return Params;
        }

        static const std::vector<FRNBOMetasoundParam>& OutputAudioParams() {
            static const std::vector<FRNBOMetasoundParam> Params = FRNBOMetasoundParam::OutputAudio(desc);
            return Params;
        }

		_OPERATOR_PARAM_DECL_
        */
	}

    /*
	class F_OPERATOR_NAME_Operator : public TExecutableOperator<F_OPERATOR_NAME_Operator>
	{
		private:
			RNBO::CoreObject CoreObject;
			RNBO::ParameterEventInterfaceUniquePtr ParamInterface;

#if _OPERATOR_ENABLE_TRANSPORT_
			FTransportReadRef Transport;

			double LastTransportBeatTime = -1.0;
			float LastTransportBPM = 0.0f;
			bool LastTransportRun = false;
			int32 LastTransportNum = 0;
			int32 LastTransportDen = 0;
#endif

			_OPERATOR_MEMBERS_DECL_
		public:
			static const FNodeClassMetadata& GetNodeInfo() {
				auto InitNodeInfo = []() -> FNodeClassMetadata
				{
					FNodeClassMetadata Info;
					Info.ClassName = { TEXT("UE"), "_OPERATOR_DISPLAYNAME_", TEXT("Audio") };
					Info.MajorVersion = 1;
					Info.MinorVersion = 1;
					Info.DisplayName = METASOUND_LOCTEXT("_OPERATOR_NAME__DisplayName", "_OPERATOR_DISPLAYNAME_");
					Info.Description = METASOUND_LOCTEXT("_OPERATOR_NAME__Description", "_OPERATOR_DESCRIPTION_");
					Info.Author = PluginAuthor;
					Info.PromptIfMissing = PluginNodeMissingPrompt;
					Info.DefaultInterface = GetVertexInterface();
					Info.CategoryHierarchy = { LOCTEXT("_OPERATOR_NAME__Category", "_OPERATOR_CATEGORY_") };
					return Info;
				};

				static const FNodeClassMetadata Info = InitNodeInfo();

				return Info;
			}

			static const FVertexInterface& GetVertexInterface() {
				auto Init = []() -> FVertexInterface
				{
					FInputVertexInterface inputs;//(_OPERATOR_VERTEX_INPUTS_);
                    
                    for (auto& p: InputFloatParams()) {
                        inputs.Add(TInputDataVertex<float>(p.Name(), p.MetaData(), p.InitialValue()));
                    }

                    for (auto& p: InputAudioParams()) {
                        inputs.Add(TInputDataVertex<FAudioBuffer>(p.Name(), p.MetaData()));
                    }

#if _OPERATOR_ENABLE_TRANSPORT_
					inputs.Add(TInputDataVertex<FTransport>(METASOUND_GET_PARAM_NAME_AND_METADATA(ParamTransport)));
#endif
					FOutputVertexInterface outputs;//(_OPERATOR_VERTEX_OUTPUTS_);

                    for (auto& p: OutputAudioParams()) {
                        outputs.Add(TOutputDataVertex<FAudioBuffer>(p.Name(), p.MetaData()));
                    }

					FVertexInterface interface(inputs, outputs);
					return interface;
				};
				static const FVertexInterface Interface = Init();

				return Interface;
			}

			static TUniquePtr<IOperator> CreateOperator(const FCreateOperatorParams& InParams, FBuildErrorArray& OutErrors) {
				const FDataReferenceCollection& InputCollection = InParams.InputDataReferences;
				const FInputVertexInterface& InputInterface = GetVertexInterface().GetInputInterface();

				return MakeUnique<F_OPERATOR_NAME_Operator>(InParams, InParams.OperatorSettings, InputCollection, InputInterface, OutErrors);
			}

			F_OPERATOR_NAME_Operator(
					const FCreateOperatorParams& InParams,
					const FOperatorSettings& InSettings,
					const FDataReferenceCollection& InputCollection,
					const FInputVertexInterface& InputInterface,
					FBuildErrorArray& OutErrors
				) :
				CoreObject(RNBO::UniquePtr<RNBO::PatcherInterface>(RNBO::_OPERATOR_NAME_FactoryFunction(RNBO::Platform::get())()))

#if _OPERATOR_ENABLE_TRANSPORT_
				, Transport(InputCollection.GetDataReadReferenceOrConstruct<FTransport>(METASOUND_GET_PARAM_NAME(ParamTransport)))
#endif

				_OPERATOR_MEMBERS_INIT_
			{
				CoreObject.prepareToProcess(InSettings.GetSampleRate(), InSettings.GetNumFramesPerBlock());
				//all params are handled in the audio thread
				ParamInterface = CoreObject.createParameterInterface(RNBO::ParameterEventInterface::NotThreadSafe, nullptr);
			}

			virtual FDataReferenceCollection GetInputs() const override
			{
				FDataReferenceCollection InputDataReferences;
#if _OPERATOR_ENABLE_TRANSPORT_
				InputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(ParamTransport), Transport);
#endif
				_OPERATOR_GET_INPUTS_
				return InputDataReferences;
			}

			virtual FDataReferenceCollection GetOutputs() const override
			{
				FDataReferenceCollection OutputDataReferences;
				_OPERATOR_GET_OUTPUTS_
				return OutputDataReferences;
			}

			void UpdateParam(RNBO::ParameterIndex i, float f) {
				double v = static_cast<double>(f);
				if (v != ParamInterface->getParameterValue(i)) {
					ParamInterface->setParameterValue(i, v);
				}
			}

			void Execute()
			{
				const std::array<const float *, _OPERATOR_AUDIO_INPUT_COUNT_> ins = { _OPERATOR_AUDIO_INPUT_INIT_ };
				std::array<float*, _OPERATOR_AUDIO_OUTPUT_COUNT_> outs = { _OPERATOR_AUDIO_OUTPUT_INIT_ };

				int32 NumFrames = _OPERATOR_AUDIO_NUMFRAMES_MEMBER_->Num();

#if _OPERATOR_ENABLE_TRANSPORT_

				double btime = std::max(0.0, Transport->GetBeatTime().GetSeconds()); //not actually seconds
				if (LastTransportBeatTime != btime)
				{ 
					LastTransportBeatTime = btime;
					RNBO::BeatTimeEvent event(0, btime);

					ParamInterface->scheduleEvent(event);
				}

				float bpm = std::max(0.0f, Transport->GetBPM());
				if (LastTransportBPM != bpm)
				{ 
					LastTransportBPM = bpm;

					RNBO::TempoEvent event(0, bpm);
					ParamInterface->scheduleEvent(event);
				}

				if (LastTransportRun != Transport->GetRun())
				{ 
					LastTransportRun = Transport->GetRun();
					RNBO::TransportEvent event(0, LastTransportRun ? RNBO::TransportState::RUNNING : RNBO::TransportState::STOPPED);
					ParamInterface->scheduleEvent(event);
				}

				auto timesig = Transport->GetTimeSig();
				auto num = std::get<0>(timesig);
				auto den = std::get<1>(timesig);
				if (LastTransportNum != num || LastTransportDen != den)
				{ 
					LastTransportNum = num;
					LastTransportDen = den;

					RNBO::TimeSignatureEvent event(0, num, den);
					ParamInterface->scheduleEvent(event);
				}
#endif

				_OPERATOR_PARAM_UPDATE_
				CoreObject.process(ins.data(), ins.size(), outs.data(), outs.size(), NumFrames);
			}
	};
*/

    using _OPERATOR_NAME_Operator = FRNBOOperator<desc, RNBO::_OPERATOR_NAME_FactoryFunction>;
    using _OPERATOR_NAME_Node = FGenericNode<_OPERATOR_NAME_Operator>;
	METASOUND_REGISTER_NODE(_OPERATOR_NAME_Node)
}

#undef LOCTEXT_NAMESPACE
