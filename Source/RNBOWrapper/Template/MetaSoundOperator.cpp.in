// based on Copyright Epic Games, Inc. All Rights Reserved.
#include "Internationalization/Text.h"
#include "MetasoundExecutableOperator.h"
#include "MetasoundNodeRegistrationMacro.h"
#include "MetasoundParamHelper.h"
#include "MetasoundPrimitives.h"
#include "MetasoundTime.h"
#include "MetasoundAudioBuffer.h"
#include "DSP/Delay.h"
#include "MetasoundStandardNodesCategories.h"
#include "MetasoundFacade.h"

#define LOCTEXT_NAMESPACE "MetasoundStandardNodes_OPERATOR_NAME_"

namespace Metasound
{
	namespace _OPERATOR_NAMESPACE_
	{
		METASOUND_PARAM(InParamFreq, "Freq", "Freq.")
		METASOUND_PARAM(OutParamAudio, "Out 1", "Audio output 1.")
	}

	class F_OPERATOR_NAME_Operator : public TExecutableOperator<F_OPERATOR_NAME_Operator>
	{
		private:
			using namespace _OPERATOR_NAMESPACE_;

			FFloatReadRef Freq;
			FAudioBufferWriteRef AudioOutput;

		public:
			static const FNodeClassMetadata& GetNodeInfo() {
				auto InitNodeInfo = []() -> FNodeClassMetadata
				{
					FNodeClassMetadata Info;
					Info.ClassName = { TEXT("UE"), "_OPERATOR_DISPLAYNAME_", TEXT("Audio") };
					Info.MajorVersion = 1;
					Info.MinorVersion = 1;
					Info.DisplayName = METASOUND_LOCTEXT("_OPERATOR_NAME__DisplayName", "_OPERATOR_DISPLAYNAME_");
					Info.Description = METASOUND_LOCTEXT("_OPERATOR_NAME__Description", "_OPERATOR_DESCRIPTION_");
					Info.Author = PluginAuthor;
					Info.PromptIfMissing = PluginNodeMissingPrompt;
					Info.DefaultInterface = GetVertexInterface();
					Info.CategoryHierarchy = { LOCTEXT("_OPERATOR_NAME__VolumeNodeCategory", "_OPERATOR_CATEGORY_") };
					return Info;
				};

				static const FNodeClassMetadata Info = InitNodeInfo();

				return Info;
			}
			static const FVertexInterface& GetVertexInterface() {
				static const FVertexInterface Interface(
						FInputVertexInterface(
							TInputDataVertex<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InParamFreq), 0.0f)
							//_OPERATOR_VERTEX_INPUTS_
							/*
							   TInputDataVertex<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(InParamAudioInput)),
							   TInputDataVertex<FTime>(METASOUND_GET_PARAM_NAME_AND_METADATA(InParamDelayTime), 1.0f),
							   TInputDataVertex<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InParamDryLevel), 0.0f),
							   TInputDataVertex<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InParamWetLevel), 1.0f),
							   TInputDataVertex<float>(METASOUND_GET_PARAM_NAME_AND_METADATA(InParamFeedbackAmount), 0.0f)
							   */
							),
						FOutputVertexInterface(
							TOutputDataVertex<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(OutParamAudio))
							//_OPERATOR_VERTEX_OUTPUTS_
							/*
							   TOutputDataVertex<FAudioBuffer>(METASOUND_GET_PARAM_NAME_AND_METADATA(OutParamAudio))
							   */
							)
						);

				return Interface;
			}

			static TUniquePtr<IOperator> CreateOperator(const FCreateOperatorParams& InParams, FBuildErrorArray& OutErrors) {
				const FDataReferenceCollection& InputCollection = InParams.InputDataReferences;
				const FInputVertexInterface& InputInterface = GetVertexInterface().GetInputInterface();

				return MakeUnique<F_OPERATOR_NAME_Operator>(InParams, InParams.OperatorSettings, InputCollection, InputInterface, OutErrors);
			}

			F_OPERATOR_NAME_Operator(
					const FCreateOperatorParams& InParams,
					const FOperatorSettings& InSettings,
					const FDataReferenceCollection& InputCollection,
					const FInputVertexInterface& InputInterface,
					FBuildErrorArray& OutErrors,
				) :
				Freq(InputCollection.GetDataReadReferenceOrConstructWithVertexDefault<float>(InputInterface, METASOUND_GET_PARAM_NAME(InParamFreq), InSettings)),
				AudioOutput(FAudioBufferWriteRef::CreateNew(InSettings))
			{

			}

			virtual FDataReferenceCollection GetInputs() const override
			{
				FDataReferenceCollection InputDataReferences;
				InputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(InParamFreq), FFloatReadRef(Freq));

				return InputDataReferences;
			}

			virtual FDataReferenceCollection GetOutputs() const override
			{
				FDataReferenceCollection OutputDataReferences;
				OutputDataReferences.AddDataReadReference(METASOUND_GET_PARAM_NAME(OutParamAudio), FAudioBufferReadRef(AudioOutput));
				return OutputDataReferences;
			}

			void Execute()
			{
				/*
				// Get clamped delay time
				float CurrentInputDelayTime = GetInputDelayTimeMsec();

				// Check to see if our delay amount has changed
				if (!FMath::IsNearlyEqual(PrevDelayTimeMsec, CurrentInputDelayTime))
				{
					PrevDelayTimeMsec = CurrentInputDelayTime;
					//DelayBuffer.SetEasedDelayMsec(PrevDelayTimeMsec);
				}

				const float* InputAudio = AudioInput->GetData();

				float* OutputAudio = AudioOutput->GetData();
				int32 NumFrames = AudioInput->Num();

				// Clamp the feedback amount to make sure it's bounded. Clamp to a number slightly less than 1.0
				float FeedbackAmount = FMath::Clamp(*Feedback, 0.0f, 1.0f - SMALL_NUMBER);
				float CurrentDryLevel = FMath::Clamp(*DryLevel, 0.0f, 1.0f);
				float CurrentWetLevel = FMath::Clamp(*WetLevel, 0.0f, 1.0f);

				if (FMath::IsNearlyZero(FeedbackAmount))
				{
					FeedbackSample = 0.0f;

					for (int32 FrameIndex = 0; FrameIndex < NumFrames; ++FrameIndex)
					{
						OutputAudio[FrameIndex] = 0;//CurrentWetLevel * DelayBuffer.ProcessAudioSample(InputAudio[FrameIndex]) + CurrentDryLevel * InputAudio[FrameIndex];
					}
				}
				else
				{
					// There is some amount of feedback so we do the feedback mixing
					for (int32 FrameIndex = 0; FrameIndex < NumFrames; ++FrameIndex)
					{
						OutputAudio[FrameIndex] = 0;//CurrentWetLevel * DelayBuffer.ProcessAudioSample(InputAudio[FrameIndex] + FeedbackSample * FeedbackAmount) + CurrentDryLevel * InputAudio[FrameIndex];
						FeedbackSample = OutputAudio[FrameIndex];
					}
				}
				*/
			}
	};

	/*
	F_OPERATOR_NAME_Operator::F_OPERATOR_NAME_Operator(
			const FOperatorSettings& InSettings,
			const FFloatReadRef& InFreq)

		: 
		, Freq(InFreq)
		, AudioOutput(FAudioBufferWriteRef::CreateNew(InSettings))
		, PrevDelayTimeMsec(GetInputDelayTimeMsec())
		, FeedbackSample(0.0f)
		{
			// DelayBuffer.Init(InSettings.GetSampleRate(), _OPERATOR_NAME_::MaxDelaySeconds);
			// DelayBuffer.SetDelayMsec(PrevDelayTimeMsec);
		}

	TUniquePtr<IOperator> F_OPERATOR_NAME_Operator::CreateOperator(const FCreateOperatorParams& InParams, FBuildErrorArray& OutErrors)
	{
		using namespace _OPERATOR_NAMESPACE_;

		const FDataReferenceCollection& InputCollection = InParams.InputDataReferences;
		const FInputVertexInterface& InputInterface = GetVertexInterface().GetInputInterface();

		FAudioBufferReadRef AudioIn = InputCollection.GetDataReadReferenceOrConstruct<FAudioBuffer>(METASOUND_GET_PARAM_NAME(InParamAudioInput), InParams.OperatorSettings);
		FTimeReadRef DelayTime = InputCollection.GetDataReadReferenceOrConstructWithVertexDefault<FTime>(InputInterface, METASOUND_GET_PARAM_NAME(InParamDelayTime), InParams.OperatorSettings);
		FFloatReadRef DryLevel = InputCollection.GetDataReadReferenceOrConstructWithVertexDefault<float>(InputInterface, METASOUND_GET_PARAM_NAME(InParamDryLevel), InParams.OperatorSettings);
		FFloatReadRef WetLevel = InputCollection.GetDataReadReferenceOrConstructWithVertexDefault<float>(InputInterface, METASOUND_GET_PARAM_NAME(InParamWetLevel), InParams.OperatorSettings);
		FFloatReadRef Feedback = InputCollection.GetDataReadReferenceOrConstructWithVertexDefault<float>(InputInterface, METASOUND_GET_PARAM_NAME(InParamFeedbackAmount), InParams.OperatorSettings);

		return MakeUnique<F_OPERATOR_NAME_Operator>(InParams.OperatorSettings, AudioIn, DelayTime, DryLevel, WetLevel, Feedback);
	}
	*/

    using _OPERATOR_NAME_Node = FGenericNode<F_OPERATOR_NAME_Operator>;
	METASOUND_REGISTER_NODE(_OPERATOR_NAME_Node)
}

#undef LOCTEXT_NAMESPACE
